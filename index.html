<html>
<head>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        /* Add these styles to your existing CSS */
        .gridlines line {
            stroke: #bbb;
        }
        .gridlines .domain {
            stroke:none;
        }

        .borough-filter,
        .rider-filter,
        #subway-toggle {
        padding: 5px;
        margin: 5px;
        display: inline-block;
        border: #d05228 solid 2px;
        color: #d05228;
        background-color: white;
        cursor: pointer;
        }
    
        .borough-filter:hover,
        .rider-filter:hover,
        #subway-toggle:hover {
        background-color: #ffc63d !important;
        }
    
        #sidebar h4 {   
        margin-top: 20px;
        margin-bottom: 10px;
        }
    
        #borough-filters,
        #rider-filters,
        #overlay-controls {
        margin-bottom: 15px;
        }
        
        /* Add these styles for the time slider */
        .brush .selection {
            fill: #ffc63d;
            fill-opacity: 0.3;
            stroke: #d05228;
        }
        
        #control {
            background-color: #ffcebf;
            padding: 10px;
            margin: 10px;
            width: fit-content;
        }

        .detailscolor {
            width: fit-content;
        }
    </style> 
</head>
<body>
    <h3>CitiBike Usage in New York City</h3>
    <p>For our project, we will look at CitiBike usage in New York City neighborhoods and compare the concentration of rides starting at each neighborhood. 
    We want to see if CitiBikes are an effective alternative means of transportation by visualizing it against the NYC Subway System and the 
    percentage of people who own a car in each neighborhood tabulation area.</p>

    <!-- Choropleth Map SVG Nick was here -->
    
    <!-- Bar Chart SVG -->

    <!-- Filters -->
    <div id="sidebar" class="detailscolor">
        <div id="clearArea"></div>
        
        <!-- Borough Filter Section -->
        <h4><strong>Filter</strong> Rides by Borough</h4>
        <div id="borough-filters"></div>
        
        <!-- Rider Type Filter Section -->
        <h4><strong>Filter</strong> by Rider Type</h4>
        <div id="rider-filters"></div>
        
        <!-- Subway Overlay Toggle -->
        <h4><strong>Overlay</strong> Subway Routes</h4>
        <div id="overlay-controls"></div>
    </div>

    <!-- Add this right after your existing sidebar div -->
    <div class="detailscolor">
        <h4><strong>Time Slider</strong> & Number of Rides Over Time</h4>
        <p>Narrow the dataset according to time ranges with the slider</p>
        <div id="control"></div>
    </div>

    <div style="margin:0 auto">
        <svg id="citibike_map" height="600" width="700" style="background: rgb(222, 220, 220); margin-top:20px; border-radius:10px"></svg>
    </div>

    <script>
        // Constants
        const boroughs = ["Manhattan", "Brooklyn", "Queens", "Bronx", "New Jersey"];
        const riderTypes = ["Member", "Casual"];

        // State variables
        let filteredBorough = [];
        let filteredRiderType = [];
        let showSubwayOverlay = false;

        // Create filter sections
        let boroughFilters = d3.select("#borough-filters");
        let riderFilters = d3.select("#rider-filters");
        let overlayControls = d3.select("#overlay-controls");

        // Add clear button
        clearArea = d3.select("#clearArea")
        let clearButton = clearArea
        .append("button")
        .attr("id", "clear")
        .text("Reset Visualizations")
        .on("click", clear);

        // Create borough filter buttons
        boroughs.forEach((borough) => {
        boroughFilters
            .append("button")
            .attr("name", borough)
            .attr("id", borough)
            .attr("class", "borough-filter")
            .attr("clicked", false)
            .text(borough)
            .on("click", function() { filterClick(this, 'borough'); });
        });

        // Create rider type filter buttons
        riderTypes.forEach((type) => {
        riderFilters
            .append("button")
            .attr("name", type)
            .attr("id", type)
            .attr("class", "rider-filter")
            .attr("clicked", false)
            .text(type)
            .on("click", function() { filterClick(this, 'rider'); });
        });

        // Create subway overlay toggle
        overlayControls
        .append("button")
        .attr("id", "subway-toggle")
        .attr("clicked", false)
        .text("Show Subway Routes")
        .on("click", toggleSubwayOverlay);

        // Filter click handler
        function filterClick(button, filterType) {
        let fil = d3.select(button);
        let buttonClass = filterType === 'borough' ? '.borough-filter' : '.rider-filter';
        
        if (filterType === 'borough') {
          // Handle borough filters (multiple selection)
          if (fil.attr("clicked") == "true") {
            // Remove borough from filtered list
           filteredBorough = filteredBorough.filter(b => b !== fil.attr("name"));
            fil.style("background-color", "white");
            fil.attr("clicked", false);
          } else {
            // Add borough to filtered list
            filteredBorough.push(fil.attr("name"));
            fil.attr("clicked", true);
            fil.style("background-color", "#ffc63d");
          }
        } else {
          // Handle rider type filter (multiple selection)
          if (fil.attr("clicked") == "true") {
            // Remove rider type from filtered list
            filteredRiderType = filteredRiderType.filter(t => t !== fil.attr("name"));
            fil.style("background-color", "white");
            fil.attr("clicked", false);
          } else {
            // Add rider type to filtered list
            filteredRiderType.push(fil.attr("name"));
            fil.attr("clicked", true);
            fil.style("background-color", "#ffc63d");
          }
        }
        
        updateFiltered();
        }

        // Subway overlay toggle handler
        function toggleSubwayOverlay() {
        let button = d3.select("#subway-toggle");
        showSubwayOverlay = !showSubwayOverlay;
        
        if (showSubwayOverlay) {
            button.style("background-color", "#ffc63d")
            .text("Hide Subway Routes");
            showSubwayLines();
        } else {
            button.style("background-color", "white")
            .text("Show Subway Routes");
            hideSubwayLines();
        }
        }

        // Create the time slider immediately after the page loads
        document.addEventListener('DOMContentLoaded', function() {
            // Time variables
            let time_start = new Date(2013, 0, 1);
            let time_end = new Date(2023, 11, 31);
            let min_date = new Date(2013, 0, 1);
            let max_date = new Date(2023, 11, 31);

            // Time slider setup with adjusted dimensions
            const control = d3.select("#control");
            const controlWidth = 600;
            const controlHeight = 40;  // Reduced from 80
            const margin = {
                top: 5,     // Reduced from 10
                right: 30, 
                bottom: 50, 
                left: 30
            };

            const controlSvg = control.append("svg")
                .attr("width", controlWidth)
                .attr("height", controlHeight + margin.bottom);  // Total height is now 90px (40 + 50)

            // Create scales for the time slider
            const timeScale = d3.scaleTime()
                .domain([min_date, max_date])
                .range([margin.left, controlWidth - margin.right]);

            // Create the brush with shorter height
            const myBrush = d3.brushX()
                .extent([[margin.left, margin.top], [controlWidth - margin.right, controlHeight - margin.top]])
                .on("brush", brushed)
                .on("end", brushended);

            // Add brush to SVG
            controlSvg.append("g")
                .attr("class", "brush")
                .call(myBrush);

            // Add axis with year and month formatting
            const timeAxis = d3.axisBottom(timeScale)
                .tickFormat(d3.timeFormat("%Y %b"))
                .ticks(d3.timeMonth.every(6));

            controlSvg.append("g")
                .attr("transform", `translate(0, ${controlHeight})`)
                .call(timeAxis)
                .selectAll("text")
                .style("text-anchor", "end")
                .attr("dx", "-.8em")
                .attr("dy", ".15em")
                .attr("transform", "rotate(-45)");

            // Brush event handlers
            function brushed(event) {
                if (!event.selection) return;
                const [x0, x1] = event.selection;
                time_start = timeScale.invert(x0);
                time_end = timeScale.invert(x1);
                console.log("Time range:", time_start, time_end); // For debugging
            }

            function brushended(event) {
                if (!event.selection) {
                    time_start = min_date;
                    time_end = max_date;
                    console.log("Reset time range"); // For debugging
                }
            }
        });

        // Update the updateFiltered function to handle hour-level filtering
        function updateFiltered() {
            let filteredData = citiBikeData;
            
            // Apply borough filter
            if (filteredBorough.length > 0) {
                filteredData = filteredData.filter(d => filteredBorough.includes(d.borough));
            }
            
            // Apply rider type filter
            if (filteredRiderType.length > 0) {
                filteredData = filteredRiderType.filter(d => filteredRiderType.includes(d.riderType));
            }
            
            // Apply time filter - assuming data has hour and month properties
            filteredData = filteredData.filter(d => {
                const date = new Date(2013, d.month - 1, 1, d.hour);
                return date >= time_start && date <= time_end;
            });
            
            updateVisualization(filteredData);
        }

        // Clear all filters
        function clear() {
        // Reset borough filters
        d3.selectAll(".borough-filter")
            .each(function() {
            d3.select(this)
                .style("background-color", "white")
                .attr("clicked", false);
            });
        
        // Reset rider type filters
        d3.selectAll(".rider-filter")
            .each(function() {
            d3.select(this)
                .style("background-color", "white")
                .attr("clicked", false);
            });
            
        // Reset subway overlay
        if (showSubwayOverlay) {
            toggleSubwayOverlay();
        }
        
        // Reset time brush if it exists
        if (typeof myBrush !== 'undefined') {
            d3.select("g.brush").call(myBrush.move, null);
        }
        
        // Reset all filter states
        filteredBorough = [];
        filteredRiderType = [];
        time_start = min_date;
        time_end = max_date;
        
        // Update visualization
        updateFiltered();
        }

        // Functions to show/hide subway lines
        function showSubwayLines() {
        // Add your subway visualization code here
        // For example:
        map.selectAll(".subway-line")
            .attr("visibility", "visible");
        }

        function hideSubwayLines() {
        // Add your subway hide code here
        map.selectAll(".subway-line")
            .attr("visibility", "hidden");
        }

        // Update visualization based on filtered data
        function updateVisualization(filteredData) {
        // Update your main visualization here
        // This function should handle updating all visual elements
        // based on the current filtered dataset
        
        // Update time series if it exists
        if (typeof makePath === 'function') {
            makePath();
        }
        
        // Update map
        updateMap(filteredData);
        
        // Update any other visualizations
        updateStatistics(filteredData);
        }

        // Simplified version to just show the map
        const renderMap = async function() {
            const mapSvg = d3.select("#citibike_map");
            const width = mapSvg.attr("width");
            const height = mapSvg.attr("height");
            const margin = { top: 20, right: 20, bottom: 20, left: 20 };
            
            try {
                // Load both datasets
                const [neighborhoods, bikeData] = await Promise.all([
                    d3.json("data/2020 Neighborhood Tabulation Areas (NTAs).geojson"),
                    d3.json("data/counts_by_ntaname.json")
                ]);

                // Calculate total rides per neighborhood
                const totalRidesByNeighborhood = {};
                Object.entries(bikeData).forEach(([neighborhood, counts]) => {
                    totalRidesByNeighborhood[neighborhood] = Object.values(counts).reduce((a, b) => a + b, 0);
                });

                // Create color scale
                const colorScale = d3.scaleSequential(d3.interpolateBlues)
                    .domain([0, d3.max(Object.values(totalRidesByNeighborhood))]);

                // Set up projection
                const projection = d3.geoMercator()
                    .fitSize([width - margin.left - margin.right, 
                             height - margin.top - margin.bottom], 
                             neighborhoods);
                const path = d3.geoPath().projection(projection);

                // Draw map
                const map = mapSvg.append("g")
                    .attr("transform", `translate(${margin.left},${margin.top})`);

                map.selectAll("path")
                    .data(neighborhoods.features)
                    .join("path")
                    .attr("d", path)
                    .attr("fill", d => {
                        const rides = totalRidesByNeighborhood[d.properties.ntaname] || 0;
                        return colorScale(rides);
                    })
                    .attr("stroke", "white")
                    .attr("stroke-width", "0.5px")
                    // Add hover effect to show neighborhood name and ride count
                    .append("title")
                    .text(d => {
                        const rides = totalRidesByNeighborhood[d.properties.ntaname] || 0;
                        return `${d.properties.ntaname}\nTotal Rides: ${rides.toLocaleString()}`;
                    });

                // Add legend
                const legendWidth = 200;
                const legendHeight = 10;

                const legendScale = d3.scaleLinear()
                    .domain(colorScale.domain())
                    .range([0, legendWidth]);

                const legendAxis = d3.axisBottom(legendScale)
                    .ticks(5)
                    .tickFormat(d3.format(",.0f"));

                const legend = mapSvg.append("g")
                    .attr("transform", `translate(${margin.left}, ${height - margin.bottom - 40})`);

                legend.append("g")
                    .call(legendAxis);

                // Create gradient for legend
                const defs = mapSvg.append("defs");
                const linearGradient = defs.append("linearGradient")
                    .attr("id", "legend-gradient")
                    .attr("x1", "0%")
                    .attr("x2", "100%")
                    .attr("y1", "0%")
                    .attr("y2", "0%");

                linearGradient.selectAll("stop")
                    .data(colorScale.ticks().map((t, i, n) => ({ 
                        offset: `${i*100/n.length}%`,
                        color: colorScale(t) 
                    })))
                    .enter()
                    .append("stop")
                    .attr("offset", d => d.offset)
                    .attr("stop-color", d => d.color);

                legend.append("rect")
                    .attr("width", legendWidth)
                    .attr("height", legendHeight)
                    .style("fill", "url(#legend-gradient)");

            } catch (error) {
                console.error("Error loading or rendering map:", error);
            }
        };

        // Initialize the map
        renderMap();

        let citiBikeData = []; // Initialize empty array at the top of your script

        // Load CitiBike data
        async function loadCitiBikeData() {
            try {
                citiBikeData = await d3.json("data/counts_by_ntaname.json");
            } catch (error) {
                console.error("Error loading CitiBike data:", error);
            }
        }

        // Call both functions
        Promise.all([renderMap(), loadCitiBikeData()]).then(() => {
            console.log("All data loaded");
        });
    </script>
</body>

</html>
